<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rechtschreibung üben</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { max-width: 1200px; margin: 24px auto; padding: 0 16px; }
    h1 { margin: 0 0 8px; font-size: 22px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; margin: 12px 0; 
      overflow: visible;
    }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .spacer { flex: 1 1 auto; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#f3f3f3; font-size:12px; }
    .small { font-size: 12px; color: #555; }

    .sentence { font-size: 22px; line-height: 1.75; white-space: normal; overflow-wrap: anywhere; 
      padding-bottom: 56px;
      }

    
.gapWrap {
  display: inline;
  position: relative;
  margin: 0;
  padding: 0;
}

.blank {
  display: inline;
  border-bottom: 3px solid #111;
  padding: 0;
  margin: 0;
  font-weight: 700;
  letter-spacing: 0;
}

.blank.done { border-bottom-color: #777; }

.choices {
  z-index: 5;

  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  top: 1.8em;
  display: flex;
  gap: 6px;
  margin: 0;
  padding: 0;
  white-space: nowrap;
}

    button.choice { padding: 7px 10px; border-radius: 10px; border: 1px solid #bbb; background: #fff; cursor: pointer; font-size: 15px; line-height: 1; }
    button.choice:disabled { cursor: not-allowed; opacity: .65; }
    button.choice.correct { background: #e7f8ea; border-color: #2e7d32; color: #1b5e20; }
    button.choice.wrong { background: #fdeaea; border-color: #c62828; color: #8e0000; }

    button.primary { padding: 10px 14px; border-radius: 10px; border: 1px solid #111; background: #111; color: #fff; cursor: pointer; font-size: 16px; }
    button.primary:disabled { opacity: .4; cursor: not-allowed; }

    table { width: 100%; border-collapse: collapse; font-size: 14px; }
    th, td { border-bottom: 1px solid #eee; padding: 8px 6px; text-align: left; }
    th { background: #fafafa; }
  </style>
</head>
<body>
  <h1>Rechtschreibung üben</h1>
  <div class="small">Grund-Set mit 100 Sätzen. Du kannst zusätzliche Sets als .txt laden (jede Zeile ein Satz) und jederzeit wechseln.</div>

  <div class="card">
    
      <div class="row">
      <div><span class="pill" id="progressPill">Satz 0</span></div>
      <div class="spacer"></div>
      <button class="primary" id="nextBtn" disabled>Weiter</button>
    </div>

    <div style="height:10px"></div>
    <div class="sentence" id="sentence"></div>
  </div>

  <div class="card">
    <div class="row">
      <div><strong>Statistik</strong></div>
      <div class="spacer"></div>
      <div class="row" style="gap:10px;align-items:center;"><div id="ampel" style="width:14px;height:14px;border-radius:50%;background:#ddd;border:1px solid #bbb;"></div><div class="small" id="overallStat"></div></div>
    </div>
    <div style="height:8px"></div>
    <table>
      <thead><tr><th>Kombination</th><th>Versuche</th><th>Richtig</th><th>Quote</th></tr></thead>
      <tbody id="statsBody"></tbody>
    </table>
  </div>


  <div class="card">
    <div class="row">
      <div><strong>Sets</strong></div>
      <div class="spacer"></div>
      <div class="row" style="gap:10px;">
        <label class="small" for="setSelect">Set:</label>
        <select id="setSelect" style="padding:8px 10px;border-radius:10px;border:1px solid #bbb;font-size:14px;max-width:420px;"></select>
        <button class="primary" id="loadSetBtn" style="background:#fff;color:#111;border:1px solid #111;">Set laden…</button>
        <input id="fileInput" type="file" accept=".txt,text/plain" style="display:none" />
      </div>
    </div>
    <div class="small" style="margin-top:8px;">
      Neue Sets: .txt-Datei wählen, jede Zeile ein Satz. Geladene Sets bleiben im Browser gespeichert und sind künftig auswählbar.
    </div>
  </div>


  <div class="card" style="margin-top:12px;">
    <div class="row">
      <div><strong>Status</strong></div>
      <div class="spacer"></div>
      <div id="versionInfo" class="pill" style="display:inline-block;"></div>
    </div>
    <div id="statusInfo" class="small" style="margin-top:8px;color:#555;"></div>
    <div id="errorBox" style="display:none;margin-top:10px;padding:10px 12px;border:1px solid #c62828;border-radius:10px;background:#fdeaea;color:#8e0000;font-size:13px;"></div>
  </div>

<script>
const BASE_LINES = ["Am Morgen packe ich meinen Rucksack und gehe zur Schule.", "Ich lese ein Buch und achte auf jedes Wort.", "Nach dem Frühstück ziehe ich meine Jacke an.", "Im Garten spiele ich mit einem Ball.", "Ich höre aufmerksam zu, wenn jemand spricht.", "Am Abend räume ich mein Zimmer auf.", "Ich schreibe langsam, damit alles gut lesbar ist.", "Wir gehen gemeinsam einen Weg entlang.", "Ich trinke Wasser, wenn ich durstig bin.", "Nach der Pause beginne ich wieder zu arbeiten.", "Am frühen Morgen packe ich meinen Rucksack und gehe zur Schule.", "Ich lese ein Buch und achte auf jedes Wort.", "Nach dem Frühstück ziehe ich meine Jacke an.", "Im Garten spiele ich mit einem Ball.", "Ich höre aufmerksam zu, wenn jemand spricht.", "Am Abend räume ich mein Zimmer auf.", "Ich schreibe langsam, damit alles gut lesbar ist.", "Wir gehen gemeinsam einen Weg entlang.", "Ich trinke Wasser, wenn ich durstig bin.", "Nach der Pause beginne ich wieder zu arbeiten.", "Heute Morgen packe ich meinen Rucksack und gehe zur Schule.", "Ich lese ein Buch und achte auf jedes Wort.", "Nach dem Frühstück ziehe ich meine Jacke an.", "Im Garten spiele ich mit einem Ball.", "Ich höre aufmerksam zu, wenn jemand spricht.", "Am Abend räume ich mein Zimmer auf.", "Ich schreibe langsam, damit alles gut lesbar ist.", "Wir gehen gemeinsam einen Weg entlang.", "Ich trinke Wasser, wenn ich durstig bin.", "Nach der Pause beginne ich wieder zu arbeiten.", "Jeden Morgen packe ich meinen Rucksack und gehe zur Schule.", "Ich lese ein Buch und achte auf jedes Wort.", "Nach dem Frühstück ziehe ich meine Jacke an.", "Im Garten spiele ich mit einem Ball.", "Ich höre aufmerksam zu, wenn jemand spricht.", "Am Abend räume ich mein Zimmer auf.", "Ich schreibe langsam, damit alles gut lesbar ist.", "Wir gehen gemeinsam einen Weg entlang.", "Ich trinke Wasser, wenn ich durstig bin.", "Nach der Pause beginne ich wieder zu arbeiten.", "Zu Beginn des Tages packe ich meinen Rucksack und gehe zur Schule.", "Ich lese ein Buch und achte auf jedes Wort.", "Nach dem Frühstück ziehe ich meine Jacke an.", "Im Garten spiele ich mit einem Ball.", "Ich höre aufmerksam zu, wenn jemand spricht.", "Am Abend räume ich mein Zimmer auf.", "Ich schreibe langsam, damit alles gut lesbar ist.", "Wir gehen gemeinsam einen Weg entlang.", "Ich trinke Wasser, wenn ich durstig bin.", "Nach der Pause beginne ich wieder zu arbeiten.", "Gleich nach dem Aufstehen packe ich meinen Rucksack und gehe zur Schule.", "Ich lese ein Buch und achte auf jedes Wort.", "Nach dem Frühstück ziehe ich meine Jacke an.", "Im Garten spiele ich mit einem Ball.", "Ich höre aufmerksam zu, wenn jemand spricht.", "Am Abend räume ich mein Zimmer auf.", "Ich schreibe langsam, damit alles gut lesbar ist.", "Wir gehen gemeinsam einen Weg entlang.", "Ich trinke Wasser, wenn ich durstig bin.", "Nach der Pause beginne ich wieder zu arbeiten.", "Vor der Schule packe ich meinen Rucksack und gehe zur Schule.", "Ich lese ein Buch und achte auf jedes Wort.", "Nach dem Frühstück ziehe ich meine Jacke an.", "Im Garten spiele ich mit einem Ball.", "Ich höre aufmerksam zu, wenn jemand spricht.", "Am Abend räume ich mein Zimmer auf.", "Ich schreibe langsam, damit alles gut lesbar ist.", "Wir gehen gemeinsam einen Weg entlang.", "Ich trinke Wasser, wenn ich durstig bin.", "Nach der Pause beginne ich wieder zu arbeiten.", "Nach dem Aufwachen packe ich meinen Rucksack und gehe zur Schule.", "Ich lese ein Buch und achte auf jedes Wort.", "Nach dem Frühstück ziehe ich meine Jacke an.", "Im Garten spiele ich mit einem Ball.", "Ich höre aufmerksam zu, wenn jemand spricht.", "Am Abend räume ich mein Zimmer auf.", "Ich schreibe langsam, damit alles gut lesbar ist.", "Wir gehen gemeinsam einen Weg entlang.", "Ich trinke Wasser, wenn ich durstig bin.", "Nach der Pause beginne ich wieder zu arbeiten.", "An diesem Morgen packe ich meinen Rucksack und gehe zur Schule.", "Ich lese ein Buch und achte auf jedes Wort.", "Nach dem Frühstück ziehe ich meine Jacke an.", "Im Garten spiele ich mit einem Ball.", "Ich höre aufmerksam zu, wenn jemand spricht.", "Am Abend räume ich mein Zimmer auf.", "Ich schreibe langsam, damit alles gut lesbar ist.", "Wir gehen gemeinsam einen Weg entlang.", "Ich trinke Wasser, wenn ich durstig bin.", "Nach der Pause beginne ich wieder zu arbeiten.", "Am Start des Tages packe ich meinen Rucksack und gehe zur Schule.", "Ich lese ein Buch und achte auf jedes Wort.", "Nach dem Frühstück ziehe ich meine Jacke an.", "Im Garten spiele ich mit einem Ball.", "Ich höre aufmerksam zu, wenn jemand spricht.", "Am Abend räume ich mein Zimmer auf.", "Ich schreibe langsam, damit alles gut lesbar ist.", "Wir gehen gemeinsam einen Weg entlang.", "Ich trinke Wasser, wenn ich durstig bin.", "Nach der Pause beginne ich wieder zu arbeiten."];
</script>

<script>
const versionInfo = document.getElementById("versionInfo");
const APP_VERSION = "v2.2"; // bump when you update
const BUILD_TIME = "2025-12-30";
if (versionInfo) versionInfo.textContent = `Version: ${APP_VERSION} (${BUILD_TIME})`;
const statusInfo = document.getElementById("statusInfo");
function setStatus(msg){ if(statusInfo) statusInfo.textContent = msg; }
setStatus("Initialisiere…");

function showError(msg) {
  const box = document.getElementById("errorBox");
  if (!box) return;
  box.style.display = "block";
  box.textContent = msg;
}


const sentenceEl = document.getElementById("sentence");
const nextBtn = document.getElementById("nextBtn");
const overallStat = document.getElementById("overallStat");
const statsBody = document.getElementById("statsBody");
const progressPill = document.getElementById("progressPill");

const setSelect = document.getElementById("setSelect");
const loadSetBtn = document.getElementById("loadSetBtn");
const fileInput = document.getElementById("fileInput");

const CATEGORIES = BASE_DATA.categories;

function shuffleInPlace(a) {
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

/* -----------------------------
   Sets: built-in + user sets
-------------------------------- */
const STORAGE_KEY = "spelling_sets_v1";

// Optional: load additional sets from the repo (GitHub Pages) via manifest at sets/index.json
// Manifest format:
// { "sets": [ { "id":"schule1", "name":"Schule 1", "file":"sets/schule1.txt" }, ... ] }
async function loadRepoManifestSets() {
  try {
    const res = await fetch(`sets/index.json?v=${encodeURIComponent(APP_VERSION)}`, { cache: "no-store" });
    if (!res.ok) return [];
    const manifest = await res.json();
    if (!manifest || !Array.isArray(manifest.sets)) return [];
    const out = [];

    for (const entry of manifest.sets) {
      if (!entry || typeof entry.name !== "string") continue;
      // allow manifest to omit file for informational entries
      if (!entry.file || typeof entry.file !== "string") continue;

      try {
        const txtRes = await fetch(`${entry.file}?v=${encodeURIComponent(APP_VERSION)}`, { cache: "no-store" });
        if (!txtRes.ok) continue;
        const text = await txtRes.text();
        const lines = text.split(/\r?\n/);

        // Build set from txt, but keep id/name from manifest
        const built = buildSetFromTxt(entry.name, lines);
        if (!built.sentences.length) continue;

        built.id = String(entry.id || ("repo_" + entry.name)).trim() || ("repo_" + Date.now());
        built.name = entry.name;
        built._source = "repo";
        out.push(built);
      } catch {
        // ignore individual set load errors
      }
    }
    return out;
  } catch {
    // Likely running as file:// (no fetch) or no manifest present
    return [];
  }
}


function loadStoredSets() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    if (!Array.isArray(parsed)) return [];
    // sanitize
    return parsed.filter(s => s && typeof s.id === "string" && typeof s.name === "string" && Array.isArray(s.sentences));
  } catch {
    return [];
  }
}

function saveStoredSets(sets) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(sets));
}

const BUILTIN_SET = (() => {
  const built = buildSetFromTxt("Grund-Set (100)", BASE_LINES);
  built.id = "base";
  built.name = "Grund-Set (100)";
  built._source = "base";
  return built;
})();

let allSets = [BUILTIN_SET, ...loadStoredSets()];
let currentSetId = BUILTIN_SET.id;

/* -----------------------------
   Sentence parsing for .txt sets
   - Each line is one sentence.
   - We automatically pick exactly 2 gaps (max 1 gap per word).
-------------------------------- */

const DIGRAPHS = [
  { s: "ck", cat: "KCK", answer: "ck", options: ["k","ck"] },
  { s: "ie", cat: "IEI", answer: "ie", options: ["ie","i"] },
  { s: "tz", cat: "TZZ", answer: "tz", options: ["tz","z"] },
];
const SINGLE = [
  { s: "k", cat: "KCK", answer: "k", options: ["k","ck"] },
  { s: "i", cat: "IEI", answer: "i", options: ["ie","i"] },
  { s: "z", cat: "TZZ", answer: "z", options: ["tz","z"] },
  { s: "p", cat: "PB",  answer: "p", options: ["p","b"] },
  { s: "b", cat: "PB",  answer: "b", options: ["p","b"] },
  { s: "t", cat: "TD",  answer: "t", options: ["t","d"] },
  { s: "d", cat: "TD",  answer: "d", options: ["t","d"] },
];

function applyCase(opt, origSpan) {
  if (origSpan && origSpan[0] === origSpan[0].toUpperCase()) {
    return opt[0].toUpperCase() + opt.slice(1);
  }
  return opt;
}


// Wörter, die nicht für Abfragen verwendet werden sollen
const MIN_WORD_LEN = 5;
// Wörter, die nicht für Abfragen verwendet werden sollen
const STOP_WORDS = new Set([
  "der","die","das","ein","eine","einer","einem","einen","eines",
  "ich","du","er","sie","es","wir","ihr","sie",
  "mein","meine","meiner","meinem","meinen",
  "dein","deine","seiner","seine","ihre","unser","unsere",
  "und","oder","aber","denn","auch","nur","noch","schon",
  "in","im","am","auf","an","mit","von","für","bei","über","unter","nach","vor"
]);
function tokenize(sentence) {
  // Keep words and separators; words include German letters and ß.
  // This allows "pro Wort max. 1 Lücke".
  const re = /[A-Za-zÄÖÜäöüß]+|[^A-Za-zÄÖÜäöüß]+/g;
  return sentence.match(re) || [];
}


function findCandidatesInWord(word) {
  const low = word.toLowerCase();
  const candidates = [];

  // digraphs first
  for (let i = 0; i < low.length - 1; i++) {
    const two = low.slice(i, i+2);
    const d = DIGRAPHS.find(x => x.s === two);
    if (d) {
      candidates.push({ start:i, len:2, cat:d.cat, answer:d.answer, options:d.options });
      i++;
    }
  }
  // singles
  for (let i = 0; i < low.length; i++) {
    const one = low[i];
    const s = SINGLE.find(x => x.s === one);
    if (s) candidates.push({ start:i, len:1, cat:s.cat, answer:s.answer, options:s.options });
  }

  if (!candidates.length) return [];

  const nonStart = candidates.filter(c => c.start > 0);
  return nonStart.length ? nonStart : candidates;
}


function buildWordNodes(word, cand) {
  const before = word.slice(0, cand.start);
  const orig = word.slice(cand.start, cand.start + cand.len);
  const after = word.slice(cand.start + cand.len);

  return [
    { t:"text", v: before },
    {
      t:"gap",
      category: cand.cat,
      answer: applyCase(cand.answer, orig),
      options: cand.options.map(o => applyCase(o, orig)),
      blankLen: 2
    },
    { t:"text", v: after }
  ];
}

function sentenceLineToNodes(line) {
  const tokens = tokenize(line);
  const wordInfos = [];

  for (let ti = 0; ti < tokens.length; ti++) {
    const tok = tokens[ti];
    
    if (/^[A-Za-zÄÖÜäöüß]+$/.test(tok)) {
      const low = tok.toLowerCase();
      if (STOP_WORDS.has(low)) continue;
      if (tok.length < MIN_WORD_LEN) continue;

      const cands = findCandidatesInWord(tok);
      if (cands.length) wordInfos.push({ ti, word: tok, cands });
    }
  }

  if (wordInfos.length < 2) return null;

  // pick 2 different words; niemals direkt nebeneinander (mindestens ein Token dazwischen)
  const w1 = wordInfos[Math.floor(Math.random() * wordInfos.length)];
  let w2 = wordInfos[Math.floor(Math.random() * wordInfos.length)];
  let guard = 0;
  while ((w2.ti === w1.ti || Math.abs(w2.ti - w1.ti) < 2) && guard++ < 50) {
    w2 = wordInfos[Math.floor(Math.random() * wordInfos.length)];
  }
  // Wenn es nicht klappt (z.B. sehr kurze Sätze), dann keine Lücken für diesen Satz
  if (Math.abs(w2.ti - w1.ti) < 2) return null;


  // Choose one candidate per word
  const c1 = w1.cands[0 + Math.floor(Math.random() * Math.min(3, w1.cands.length))];
  const c2 = w2.cands[0 + Math.floor(Math.random() * Math.min(3, w2.cands.length))];

  // Build nodes
  const nodes = [];
  for (let ti = 0; ti < tokens.length; ti++) {
    const tok = tokens[ti];
    if (ti === w1.ti) nodes.push(...buildWordNodes(tok, c1));
    else if (ti === w2.ti) nodes.push(...buildWordNodes(tok, c2));
    else nodes.push({ t:"text", v: tok });
  }

  // Merge adjacent text nodes
  const merged = [];
  for (const n of nodes) {
    if (merged.length && n.t === "text" && merged[merged.length-1].t === "text") merged[merged.length-1].v += n.v;
    else merged.push(n);
  }
  return { nodes: merged };
}

function buildSetFromTxt(name, lines) {
  const sentences = [];
  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line) continue;
    const obj = sentenceLineToNodes(line);
    if (obj) sentences.push(obj);
  }
  return { id: "user_" + Date.now(), name, sentences };
}

/* -----------------------------
   App State (current set)
-------------------------------- */
let DATA = { categories: CATEGORIES, sentences: BUILTIN_SET.sentences };
let stats = null;
let used = 0;
let current = null;
let gapsMeta = [];
let solved = [];
let correctCounted = [];
let hadWrong = [];
let countedAttempt = [];

function resetStatsAndProgress() {
  stats = { overall: { attempts: 0, correct: 0 }, perCat: {} };
  const ampel = document.getElementById("ampel");
  if (ampel) ampel.style.background = "#ddd";
  for (const c of DATA.categories) stats.perCat[c.key] = { label: c.label, attempts: 0, correct: 0 };
  used = 0;
  current = null;
  DATA._remaining = null;
  overallStat.textContent = "";
  statsBody.innerHTML = "";
  progressPill.textContent = "Satz 0";
}

function pickNextSentence() {
  if (!DATA._remaining || DATA._remaining.length === 0) DATA._remaining = shuffleInPlace([...DATA.sentences]);
  return DATA._remaining.pop();
}

function blankHtml(len) { return "&nbsp;".repeat(Math.max(2, len)); }

function renderSentence() {
  current = pickNextSentence();
  used++;

  gapsMeta = [];
  let gapIndex = 0;
  let html = "";

  for (const node of current.nodes) {
    if (node.t === "text") {
      html += escapeHtml(node.v);
    } else if (node.t === "gap") {
      const i = gapIndex++;
      gapsMeta.push({ category: node.category, answer: node.answer, options: node.options, blankLen: node.blankLen });
      html += `<span class="gapWrap" data-gap="${i}"><span class="blank" id="blank${i}">${blankHtml(node.blankLen)}</span><span class="choices" id="choices${i}">${node.options.map(opt => `<button class="choice" data-gap="${i}" data-opt="${escapeAttr(opt)}">${escapeHtml(opt)}</button>`).join("")}</span></span>`;
    }
  }

  solved = Array(gapsMeta.length).fill(false);
  correctCounted = Array(gapsMeta.length).fill(false);
  hadWrong = Array(gapsMeta.length).fill(false);
  countedAttempt = Array(gapsMeta.length).fill(false);
  nextBtn.disabled = true;

  progressPill.textContent = `Satz ${used}`;
  // Sicherstellen: niemals zwei Lücken direkt nacheinander
  if (html.includes('</span><span class="gapWrap"')) {
    // erneut wählen
    return renderSentence();
  }
  sentenceEl.innerHTML = html;

  sentenceEl.querySelectorAll("button.choice").forEach(btn => {
    btn.addEventListener("click", () => onChoose(Number(btn.dataset.gap), btn.dataset.opt, btn));
  });

  updateStatsUI();
}

function onChoose(gapIndex, chosen, btn) {
  const g = gapsMeta[gapIndex];
  const catKey = g.category;

  const firstAttemptThisClick = !countedAttempt[gapIndex];

  if (!countedAttempt[gapIndex]) {
    countedAttempt[gapIndex] = true;
    stats.overall.attempts++;
    stats.perCat[catKey].attempts++;
  }

  const choicesEl = document.getElementById(`choices${gapIndex}`);
  choicesEl.querySelectorAll("button.choice").forEach(b => b.classList.remove("wrong","correct"));

  const isCorrect = (chosen === g.answer);

  if (isCorrect) {
    btn.classList.add("correct");
    solved[gapIndex] = true;

    const blank = document.getElementById(`blank${gapIndex}`);
    blank.textContent = g.answer;
    blank.classList.add("done");

    if (!correctCounted[gapIndex]) {
      correctCounted[gapIndex] = true;
      // Nur zählen, wenn es beim ersten Klick direkt richtig war
      if (firstAttemptThisClick) {
        stats.overall.correct++;
        stats.perCat[catKey].correct++;
      }
    }
    choicesEl.querySelectorAll("button.choice").forEach(b => b.disabled = true);
  } else {
    hadWrong[gapIndex] = true;
    btn.classList.add("wrong");
  }

  nextBtn.disabled = !solved.every(Boolean);
  updateStatsUI();
}

function updateStatsUI() {
  const rate = stats.overall.attempts ? (stats.overall.correct / stats.overall.attempts) * 100 : 0;
  overallStat.textContent = `Total: ${stats.overall.correct} richtig von ${stats.overall.attempts} Versuchen (${Math.round(rate)}%)`;
  const ampel = document.getElementById("ampel");
  if (ampel) {
    if (rate >= 90) ampel.style.background = "#2e7d32";
    else if (rate >= 60) ampel.style.background = "#f9a825";
    else ampel.style.background = "#c62828";
  }
  statsBody.innerHTML = "";
  for (const key of Object.keys(stats.perCat)) {
    const s = stats.perCat[key];
    const rate = s.attempts ? Math.round((s.correct / s.attempts) * 100) : 0;
    const tr = document.createElement("tr");
    tr.innerHTML = `<td>${escapeHtml(s.label)}</td><td>${s.attempts}</td><td>${s.correct}</td><td>${rate}%</td>`;
    statsBody.appendChild(tr);
  }
}

function escapeHtml(str) { return String(str).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;"); }
function escapeAttr(str) { return String(str).replaceAll("&","&amp;").replaceAll('"',"&quot;").replaceAll("<","&lt;").replaceAll(">","&gt;"); }

/* -----------------------------
   UI: set switching + load
-------------------------------- */

function refreshSetSelect() {
  setSelect.innerHTML = "";
  for (const s of allSets) {
    const opt = document.createElement("option");
    opt.value = s.id;
    opt.textContent = s.name + (s.id === "base" ? "" : (s._source === "repo" ? " (Repo)" : " (lokal)"));
    setSelect.appendChild(opt);
  }
  setSelect.value = currentSetId;
}

function switchToSet(id) {
  const s = allSets.find(x => x.id === id);
  if (!s) return;
  currentSetId = id;
  DATA = { categories: CATEGORIES, sentences: s.sentences };
  resetStatsAndProgress();
  renderSentence();
}

setSelect.addEventListener("change", () => switchToSet(setSelect.value));

loadSetBtn.addEventListener("click", () => fileInput.click());

fileInput.addEventListener("change", async () => {
  const file = fileInput.files && fileInput.files[0];
  fileInput.value = "";
  if (!file) return;

  const text = await file.text();
  const lines = text.split(/\r?\n/);

  const name = file.name.replace(/\.[^.]+$/, "");
  const newSet = buildSetFromTxt(name, lines);

  if (!newSet.sentences.length) {
    alert("Keine verwendbaren Sätze gefunden. Hinweise:\n- Jede Zeile ein Satz\n- Mindestens zwei Wörter mit passenden Stellen (k/ck, ie/i, tz/z, p/b, t/d).");
    return;
  }

  // Store (persist) and add
  const stored = loadStoredSets();
  stored.push(newSet);
  saveStoredSets(stored);

  // Update in-memory list
  allSets = [BUILTIN_SET, ...stored];
  currentSetId = newSet.id;
  refreshSetSelect();
  switchToSet(newSet.id);
});

nextBtn.addEventListener("click", renderSentence);

/* init */
window.addEventListener('DOMContentLoaded', async () => {
  try {
    setStatus('Lade Sets…');
    const stored = loadStoredSets();
    const repoSets = await loadRepoManifestSets();
    allSets = [BUILTIN_SET, ...repoSets, ...stored];
    setStatus(`Sets geladen: ${allSets.length}`);
    currentSetId = BUILTIN_SET.id;
    refreshSetSelect();
    switchToSet(currentSetId);
    setStatus(`Bereit (Set: ${BUILTIN_SET.name})`);
  } catch (err) {
    showError('Initialisierung fehlgeschlagen: ' + (err && err.message ? err.message : String(err)));
  }
});
</script>
</body>
</html>
